/**
 * HTML sanitiser for LLM-generated output.
 *
 * Strips dangerous elements while preserving:
 * - HTML comments (section markers like <!-- bb-section:name -->)
 * - Inline SVG
 * - Netlify Forms attributes (data-netlify, netlify, name)
 * - Relative URLs
 * - <script type="application/ld+json"> (JSON-LD structured data)
 */

// ---------------------------------------------------------------------------
// JSON-LD preservation
// ---------------------------------------------------------------------------

/** Matches <script type="application/ld+json">...</script> blocks. */
const JSONLD_RE = /<script\s+type\s*=\s*["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script\s*>/gi;

/**
 * Extract JSON-LD blocks, replacing with placeholders.
 * Returns the modified HTML and an array of validated JSON-LD strings.
 */
function extractJsonLd(html: string): { html: string; blocks: string[] } {
  const blocks: string[] = [];
  const modified = html.replace(JSONLD_RE, (_match, content: string) => {
    try {
      // Round-trip through JSON.parse → JSON.stringify to strip anything
      // that isn't valid JSON. Escape </ sequences to prevent script breakout.
      const parsed: unknown = JSON.parse(content);
      const safe = JSON.stringify(parsed).replace(/</g, "\\u003c");
      const placeholder = `__JSONLD_${blocks.length}__`;
      blocks.push(safe);
      return placeholder;
    } catch {
      // Invalid JSON — discard the block entirely
      return "";
    }
  });
  return { html: modified, blocks };
}

/**
 * Restore validated JSON-LD blocks from placeholders.
 */
function restoreJsonLd(html: string, blocks: string[]): string {
  let result = html;
  for (let i = 0; i < blocks.length; i++) {
    result = result.replace(
      `__JSONLD_${i}__`,
      `<script type="application/ld+json">${blocks[i]}</script>`,
    );
  }
  return result;
}

// ---------------------------------------------------------------------------
// Patterns
// ---------------------------------------------------------------------------

/** Matches <script>...</script>, self-closing <script />, and unclosed <script> tags. */
const SCRIPT_TAG_RE = /<script\b[^>]*>[\s\S]*?<\/script\s*>/gi;
const UNCLOSED_SCRIPT_RE = /<script\b[^>]*>/gi;

/** Matches <iframe>, <object>, <embed>, <base> tags (opening or self-closing). */
const DANGEROUS_TAGS_RE = /<\/?(?:iframe|object|embed|base)\b[^>]*\/?>/gi;

/** Matches event handler attributes like onclick="...", onerror='...'. */
const EVENT_HANDLER_RE = /\s+on[a-z]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s>]+)/gi;

/**
 * Matches javascript: and data: URLs in href/src/action attributes.
 * Also catches HTML entity-encoded variants (&#106;avascript:, &#x6A;avascript:, etc.)
 */
const DANGEROUS_URL_RE =
  /(\s(?:href|src|action)\s*=\s*(?:"|'))(?:(?:&#x?[0-9a-f]+;?|&#?\w+;?)*\s*j\s*a\s*v\s*a\s*s\s*c\s*r\s*i\s*p\s*t|javascript|data)\s*:/gi;

/** Matches http:// in href/src attributes (to upgrade to https). */
const HTTP_URL_RE = /(\s(?:href|src)\s*=\s*(?:"|'))http:\/\//gi;

// ---------------------------------------------------------------------------
// Sanitiser
// ---------------------------------------------------------------------------

/**
 * Sanitise HTML generated by Claude.
 *
 * Removes:
 * - <script> tags and contents
 * - Event handler attributes (on*="")
 * - javascript: and data: URLs in href/src/action
 * - <iframe>, <object>, <embed> tags
 *
 * Upgrades:
 * - http:// to https:// in link/src attributes
 *
 * Preserves:
 * - HTML comments (section markers)
 * - Inline SVG
 * - Netlify Forms attributes
 * - Relative URLs
 * - <script type="application/ld+json"> blocks (validated via JSON round-trip)
 */
export interface SanitiseResult {
  html: string;
  stripped: string[];
}

export function sanitiseHtml(html: string): SanitiseResult {
  const stripped: string[] = [];

  // 0. Extract JSON-LD blocks before script stripping (validated via JSON round-trip)
  const { html: withoutJsonLd, blocks } = extractJsonLd(html);
  let sanitised = withoutJsonLd;

  // 1. Strip <script> tags and contents (closed first, then unclosed)
  sanitised = sanitised.replace(SCRIPT_TAG_RE, (match) => {
    stripped.push(`Removed <script> tag: ${match.slice(0, 80)}`);
    return "";
  });
  sanitised = sanitised.replace(UNCLOSED_SCRIPT_RE, (match) => {
    stripped.push(`Removed unclosed <script>: ${match.slice(0, 80)}`);
    return "";
  });

  // 2. Strip dangerous embed tags (iframe, object, embed, base)
  sanitised = sanitised.replace(DANGEROUS_TAGS_RE, (match) => {
    stripped.push(`Removed dangerous tag: ${match.slice(0, 80)}`);
    return "";
  });

  // 3. Strip event handler attributes
  sanitised = sanitised.replace(EVENT_HANDLER_RE, (match) => {
    stripped.push(`Removed event handler: ${match.trim().slice(0, 80)}`);
    return "";
  });

  // 4. Neutralise javascript: and data: URLs
  sanitised = sanitised.replace(DANGEROUS_URL_RE, (_match, prefix: string) => {
    stripped.push("Neutralised dangerous URL (javascript:/data:)");
    return `${prefix}about:blank`;
  });

  // 5. Upgrade http:// to https:// in links/sources
  sanitised = sanitised.replace(HTTP_URL_RE, "$1https://");

  // 6. Restore validated JSON-LD blocks
  sanitised = restoreJsonLd(sanitised, blocks);

  return { html: sanitised, stripped };
}

/**
 * Backwards-compatible wrapper that returns just the sanitised HTML string.
 * Used by callers that don't need the stripped report.
 */
export function sanitiseHtmlString(html: string): string {
  return sanitiseHtml(html).html;
}

// ---------------------------------------------------------------------------
// CSS Sanitiser
// ---------------------------------------------------------------------------

/** Strips </style> breakout attempts from CSS strings. */
const STYLE_BREAKOUT_RE = /<\/\s*style\s*>/gi;

/** Strips @import rules that could load external resources.
 *  Handles quoted URLs containing semicolons (e.g. Google Fonts multi-family URLs). */
const CSS_IMPORT_RE = /@import\s+(?:url\s*\(\s*(?:'[^']*'|"[^"]*"|[^)]*)\s*\)|'[^']*'|"[^"]*"|[^;]+)\s*;?\s*/gi;

/** Strips expression() (IE-era JavaScript-in-CSS). */
const CSS_EXPRESSION_RE = /expression\s*\(/gi;

/** Strips url() with javascript: or data: schemes. */
const CSS_DANGEROUS_URL_RE = /url\s*\(\s*(?:"|')?(?:javascript|data)\s*:/gi;

/**
 * Sanitise CSS generated by Claude.
 *
 * Removes:
 * - </style> breakout sequences (could inject HTML/scripts)
 * - @import rules (could load external stylesheets / exfiltrate data)
 * - expression() (IE JavaScript-in-CSS)
 * - url() with javascript: or data: schemes
 */
export interface CssSanitiseResult {
  css: string;
  stripped: string[];
}

/** Matches CSS comments. */
const CSS_COMMENT_RE = /\/\*[\s\S]*?\*\//g;

export function sanitiseCss(css: string): CssSanitiseResult {
  const stripped: string[] = [];
  let sanitised = css;
  sanitised = sanitised.replace(STYLE_BREAKOUT_RE, () => {
    stripped.push("Blocked </style> breakout");
    return "/* blocked */";
  });

  // Protect CSS comments before running @import regex — prevents false
  // positives when @import is mentioned inside a comment (e.g.
  // "/* Google Fonts loaded via <link>, not via @import */").
  const comments: string[] = [];
  const withoutComments = sanitised.replace(CSS_COMMENT_RE, (match) => {
    comments.push(match);
    return `__CSS_COMMENT_${comments.length - 1}__`;
  });
  let importSanitised = withoutComments.replace(CSS_IMPORT_RE, (match) => {
    stripped.push(`Blocked @import: ${match.slice(0, 80)}`);
    return "/* blocked */";
  });
  for (let i = 0; i < comments.length; i++) {
    importSanitised = importSanitised.replace(`__CSS_COMMENT_${i}__`, comments[i]!);
  }
  sanitised = importSanitised;

  sanitised = sanitised.replace(CSS_EXPRESSION_RE, () => {
    stripped.push("Blocked expression()");
    return "/* blocked */(";
  });
  sanitised = sanitised.replace(CSS_DANGEROUS_URL_RE, () => {
    stripped.push("Blocked dangerous url() (javascript:/data:)");
    return 'url("about:blank';
  });
  return { css: sanitised, stripped };
}
